Directory Tree:
./
    README.md
    .gitignore
    .gitmodules
    genesis.json
    foundry.toml
    output.txt
    dockerfiles/
        README.md
        core-v2.Dockerfile
        testnet.Dockerfile
        testnet.compose.yaml
        core-v2.base.Dockerfile
    bin/
        README.md
        deploy.sh
        develop.sh
        testnet.sh
        tests.sh
        testnet-config.sh
    utils/
        generateTestVectorRSA.py
    test/
        RsaVerifyOptimizedTest.t.sol
        KeyringCoreV2BaseTest.t.sol
    script/
        unsafe.s.sol
    src/
        KeyringCoreV2.sol
        unsafe/
            KeyringCoreV2Unsafe.sol
        base/
            KeyringCoreV2Base.sol


File Contents:

--- ./README.md ---
### Project Documentation

#### Table of Contents
1. [Introduction](#introduction)
2. [Project Structure](#project-structure)
3. [Smart Contracts](#smart-contracts)
4. [Scripts](#scripts)
5. [Utilities](#utilities)
6. [Tests](#tests)
7. [Dockerfiles](#dockerfiles)
8. [Usage Information](#usage-information)
9. [Environment Setup](#environment-setup)

---

### Introduction

This project contains the implementation of Keyring Contracts: Version 2.0, a robust system for managing policy states, credentials, and entity whitelisting/blacklisting on the Ethereum blockchain. The project is built using Foundry and includes comprehensive testing, deployment, and local development environments.

---

### Project Structure

The repository is organized into the following directories and files:

- **README.md**: Provides an overview and quickstart guide for the project.
- **.gitignore**: Specifies files and directories to be ignored by git.
- **.gitmodules**: Contains git submodule configurations.
- **genesis.json**: The genesis file for the local testnet.
- **foundry.toml**: Configuration file for Foundry.
- **dockerfiles/**: Contains Dockerfiles and Docker Compose configurations.
- **bin/**: Includes various shell scripts for building, deploying, and testing the project.
- **utils/**: Utility scripts for generating test vectors.
- **test/**: Solidity test files.
- **script/**: Deployment and configuration scripts.
- **src/**: Solidity smart contract source files.

---

### Smart Contracts

#### KeyringCoreV2.sol

- **Purpose**: Manages policy states, credentials, and whitelisting/blacklisting of entities.
- **Features**:
  - Credential creation with RSA signature verification.
  - Key registration and revocation.
  - Entity blacklisting and unblacklisting.
  - Fee collection by admin.

#### KeyringCoreV2Base.sol

- **Purpose**: Provides base functionalities for the KeyringCoreV2 contract.
- **Features**:
  - Admin management.
  - Key entry and entity data structures.
  - Event emissions for key and credential activities.

#### KeyringCoreV2Unsafe.sol

- **Purpose**: Unsafe version of KeyringCoreV2 for testing purposes only.

---

### Scripts

#### unsafe.s.sol

- **Purpose**: Script for deploying the `KeyringCoreV2Unsafe` contract.
- **Usage**:
  ```sh
  forge script script/unsafe.s.sol --rpc-url <RPC_URL> --private-key <PRIVATE_KEY>
  ```

---

### Utilities

#### generateTestVectorRSA.py

- **Purpose**: Python script to generate test vectors for RSA-based signatures.
- **Features**:
  - RSA key generation.
  - Message encoding and signing.
  - Signature verification.

---

### Tests

#### RsaVerifyOptimizedTest.t.sol

- **Purpose**: Tests the RSA verification logic.
- **Features**:
  - Verify RSA signatures.
  - Measure gas usage for verification.

#### KeyringCoreV2BaseTest.t.sol

- **Purpose**: Comprehensive tests for the KeyringCoreV2Base contract.
- **Features**:
  - Admin functionality tests.
  - Key registration and revocation.
  - Credential creation and validation.
  - Entity blacklisting and unblacklisting.

---

### Dockerfiles

#### core-v2.base.Dockerfile

- **Purpose**: Sets up a lightweight Ubuntu environment for Solidity development.
- **Usage**:
  ```sh
  docker build -t core-v2:base -f dockerfiles/core-v2.base.Dockerfile .
  ```

#### core-v2.Dockerfile

- **Purpose**: Builds upon the base image to set up the environment for compiling and running the project.
- **Usage**:
  ```sh
  docker build -t core-v2:latest -f dockerfiles/core-v2.Dockerfile .
  ```

#### testnet.Dockerfile

- **Purpose**: Configures and runs a local Anvil testnet node.
- **Usage**:
  ```sh
  docker build -t core-v2:testnet -f dockerfiles/testnet.Dockerfile .
  ```

#### testnet.compose.yaml

- **Purpose**: Sets up a local testnet environment using Docker Compose.
- **Usage**:
  ```sh
  docker-compose -f dockerfiles/testnet.compose.yaml up
  ```

---

### Usage Information

#### Quickstart

1. **Build Docker Images**:
   ```sh
   bash bin/develop.sh
   ```

2. **Start a Local Testnet in Docker**:
   ```sh
   bash bin/testnet.sh
   ```

3. **Run Solidity Tests in Docker**:
   ```sh
   bash bin/tests.sh
   ```

#### Local Development

1. **Build Contracts**:
   ```sh
   forge build
   ```

2. **Run Tests**:
   ```sh
   forge test
   ```

3. **Gas Snapshots**:
   ```sh
   forge snapshot
   ```

4. **Deploy Contracts**:
   ```sh
   forge script script/Counter.s.sol:CounterScript --rpc-url <your_rpc_url> --private-key <your_private_key>
   ```

---

### Environment Setup

1. **Install Dependencies**:
   - Docker
   - jq (for `testnet-config.sh`)

2. **Clone the Repository**:
   ```sh
   git clone <repository_url>
   cd <repository_directory>
   ```

3. **Initialize Submodules**:
   ```sh
   git submodule update --init --recursive
   ```

4. **Install Foundry**:
   ```sh
   curl -L https://foundry.paradigm.xyz | bash
   ~/.foundry/bin/foundryup
   ```

5. **Build Docker Images**:
   ```sh
   bash bin/develop.sh
   ```

6. **Start Local Testnet**:
   ```sh
   bash bin/testnet.sh
   ```

---

For detailed descriptions and usage of the scripts, please refer to the respective README.md files in the `bin/` and `dockerfiles/` directories. For additional documentation, visit the [Foundry Documentation](https://book.getfoundry.sh/).
--- ./.gitignore ---
# Compiler files
cache/
out/

# Ignores development broadcast logs
!/broadcast
/broadcast/*/31337/
/broadcast/**/dry-run/

# Docs
docs/

# Dotenv file
.env

--- ./.gitmodules ---
[submodule "lib/forge-std"]
	path = lib/forge-std
	url = https://github.com/foundry-rs/forge-std

--- ./genesis.json ---
{
  "chainId": "0x539",
  "nonce": "0x42",
  "timestamp": "0x0",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x1388",
  "difficulty": "0x400000000",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "stateRoot": "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
  "alloc": {
    "0x7C010FD1B3e279ac063d862199484254f27C2C44": {
      "balance": "0xad78ebc5ac6200000"
    }
  },
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}

--- ./foundry.toml ---
[profile.default]
src = "src"
out = "out"
libs = ["lib"]

# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options

--- ./output.txt ---

--- ./dockerfiles/README.md ---
# V2 Dockerfiles

Necessary configurations to build and manage Docker environments for the core-v2 project, facilitating local development, testing, and deployment.

## Table of Contents

- [Dockerfiles](#dockerfiles)
  - [core-v2.base.Dockerfile](#core-v2basedockerfile)
  - [core-v2.Dockerfile](#core-v2dockerfile)
  - [testnet.Dockerfile](#testnetdockerfile)
- [Docker Compose Files](#docker-compose-files)
  - [testnet.compose.yaml](#testnetcomposeyaml)

## Dockerfiles

### core-v2.base.Dockerfile

This Dockerfile sets up a lightweight Ubuntu 20.04 environment with necessary tools for Solidity development. It installs dependencies, sets the timezone, and installs Foundry (Forge and Cast). The project directory is prepared and dependencies are initialized using Forge.

**Usage:**
```bash
docker build -t core-v2:base -f dockerfiles/core-v2.base.Dockerfile .
```

### core-v2.Dockerfile

This Dockerfile builds upon the `core-v2:base` image to set up the environment for compiling and running the core-v2 project. It compiles the Solidity contracts and includes all necessary project files for deployment and testing.

**Usage:**
```bash
docker build -t core-v2:latest -f dockerfiles/core-v2.Dockerfile .
```

### testnet.Dockerfile

This Dockerfile extends the `core-v2:latest` image to configure and run a local Anvil testnet node. It sets environment variables, exposes the testnet port, and runs the testnet configuration script to start the node.

**Usage:**
```bash
docker build -t core-v2:testnet -f dockerfiles/testnet.Dockerfile .
```

## Docker Compose Files

### testnet.compose.yaml

This Docker Compose file sets up a local testnet environment for deploying and testing smart contracts using core-v2. It defines two services:
- `node`: Runs a local RPC node for the testnet.
- `deploy-contracts`: Deploys smart contracts to the local testnet node.

**Usage:**
```bash
docker-compose -f dockerfiles/testnet.compose.yaml up
```
--- ./dockerfiles/core-v2.Dockerfile ---
# This Dockerfile builds upon the base image `core-v2:base` to set up the environment for compiling and running the core-v2 project.
# It compiles the Solidity contracts and includes all necessary project files for deployment and testing.

FROM core-v2:base

# Compile
COPY src ./src
RUN forge build

# Copy the remaining project files
COPY bin ./bin
COPY script ./script
COPY test ./test
COPY genesis.json .
--- ./dockerfiles/testnet.Dockerfile ---
# This Dockerfile extends the core-v2:latest image to configure and run a local Anvil testnet node.

FROM core-v2:latest

ENV ANVIL_CHAIN=1337
ENV ANVIL_PORT=8545
ENV ANVIL_DNS=0.0.0.0

EXPOSE $ANVIL_PORT

ENTRYPOINT [ \
    "/bin/bash", "-c", \
    "./bin/testnet-config.sh \
            --host ${ANVIL_DNS} \
            --port ${ANVIL_PORT} \
            --chain ${ANVIL_CHAIN} \
            --genesis ./genesis.json \
        && tail -f /dev/null" \
]
--- ./dockerfiles/testnet.compose.yaml ---
# This Docker Compose file sets up a local testnet environment for deploying and testing smart contracts using core-v2.
# It defines two services: a local RPC node and a service to deploy contracts.
version: '3.8'

services:
  # This is the local RPC node that we will use to deploy the contracts.
  node:
    image: core-v2:latest
    ports:
      - "8545:8545"
    networks:
      - local-rpc
    # NB: Make sure to use `'` instead of `"` and escape the inner `'` with `\'`.
    #     We also need the `sh -c "... && tail -f /dev/null"` to keep the container running.
    #     It doesn't work without the `sh -c`
    command: |
      sh -c ' \
        bash ./bin/testnet-config.sh \
          --host 0.0.0.0 \
          --port 8545 \
          --chain 1337 \
          --genesis ./genesis.json \
          --fund-account 0x7C010FD1B3e279ac063d862199484254f27C2C44 \
        && tail -f /dev/null \
      '
    healthcheck:
      test: ["CMD", "curl", "-f", "http://node:8545"]
      interval: 0.1s
      timeout: 0.1s
      retries: 20

  # This is the service that will deploy the contracts.
  deploy-contracts:
    image: core-v2:latest
    depends_on:
      - node
    networks:
      - local-rpc
    command: >
      bash ./bin/deploy.sh
        --rpc http://node:8545
        --chain 1337
        --private-key 0x024cf65eb3bc550a1a6675aa21d146d7476fc5b62715d24fb2e0027647a213af

networks:
  local-rpc:

--- ./dockerfiles/core-v2.base.Dockerfile ---
# This Dockerfile sets up a lightweight Ubuntu 20.04 environment with necessary tools for Solidity development.
# It installs dependencies, sets the timezone, and installs Foundry (Forge and Cast).
# The project directory is prepared and dependencies are initialized using Forge.

# Use a lightweight base image
FROM ubuntu:20.04

# Set the timezone to UTC non-interactively
ENV TZ=Etc/UTC
RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y \
    tzdata \
    curl \
    git \
    build-essential \
    libssl-dev \
    pkg-config \
    jq \
    openssl \
    xxd

# Install Foundry (Forge and Cast)
RUN curl -L https://foundry.paradigm.xyz | bash \
    && ~/.foundry/bin/foundryup

# Ensure the PATH includes Foundry binaries
ENV PATH="/root/.foundry/bin:${PATH}"

# Set up the project directory
WORKDIR /usr/src/app

# Copy the .git directory to ensure forge install works correctly
COPY .git .git
COPY foundry.toml .
COPY lib ./lib

# Initialize the Forge project
RUN forge install
--- ./bin/README.md ---
Scripts for building, deploying, and managing the `core-v2` project.

## Table of Contents

- [Requirements](#requirements)
- [Scripts](#scripts)
  - [Deploy Smart Contracts (`deploy.sh`)](#deploy-smart-contracts-deploysh)
  - [Build Docker Dev Environments (`develop.sh`)](#build-docker-dev-environments-developsh)
  - [Start a Testnet in a Shell (`testnet-config.sh`)](#start-a-testnet-in-a-shell-testnet-configsh)
  - [Build Env and Start Testnet in Docker (`testnet.sh`)](#build-env-and-start-testnet-in-docker-testnetsh)
  - [Run Solidity Tests (`tests.sh`)](#run-solidity-tests-testssh)


## Requirements 
- `docker`
- `jq` for `testnet-config.sh`

## Scripts

### Deploy Smart Contracts (`deploy.sh`)

This script deploys smart contracts to a specified Ethereum network using Foundry's Forge tool.

**Usage:**
```bash
bash bin/deploy.sh --rpc <RPC_URL> --chain <CHAIN_ID> --private-key <PRIVATE_KEY>
```
**Options:**
- `--rpc`: The RPC URL of the network.
- `--chain`: The chain ID of the network.
- `--private-key`: The private key of the deployer account.
- `--help`: Display help message with usage instructions.

### Build Docker Dev Environments (`develop.sh`)

Builds Docker images for the `core-v2` project and sets up the development environment.

**Usage:**
```bash
bash bin/develop.sh
```

### Configure and Start a Testnet (`testnet-config.sh`)

Configures and starts a local Anvil testnet node with the specified parameters.

**Usage:**
```bash
bash bin/testnet-config.sh --host <HOST> --port <PORT> --chain <CHAIN_ID> --genesis <GENESIS_FILE> --fund-account <ACCOUNT>
```
**Options:**
- `--host`: Testnet host.
- `--port`: Testnet port.
- `--chain`: Testnet chain ID.
- `--genesis`: Path to the genesis file.
- `--fund-account`: Account to be funded in the genesis file.
- `--help`: Display help message with usage instructions.

### Build Env and Start Testnet in Docker (`testnet.sh`)

Builds Docker images and starts a local testnet environment for the `core-v2` project.

**Usage:**
```bash
bash bin/testnet.sh
```

### Run Solidity Tests (`tests.sh`)

Builds the `core-v2` Docker image and runs Solidity tests within a Docker container.

**Usage:**
```bash
bash bin/tests.sh
```
--- ./bin/deploy.sh ---
#!/bin/bash

# This script is used to deploy smart contracts to a specified Ethereum network.
# It accepts command line arguments for configuration and uses Foundry's Forge tool for deployment.
#
# Command Line Arguments:
# --rpc: The RPC URL of the network to which the contracts will be deployed (default: http://localhost:8545).
# --chain: The chain ID of the network (default: 1337).
# --private-key: The private key of the deployer account (default: 0x024cf65eb3bc550a1a6675aa21d146d7476fc5b62715d24fb2e0027647a213af).
# --help: Displays the help message with usage instructions.
#
# Example Usage:
# bash bin/deploy.sh --rpc http://localhost:8545 --chain 1337 --private-key 0x024cf65eb3bc550a1a6675aa21d146d7476fc5b62715d24fb2e0027647a213af
#
# Notes:
# - The script assumes that `forge build` has already been run and the contracts are compiled.
# - The script uses the `forge script` command to deploy the contract defined in `unsafe.s.sol`.
#
# The script will terminate on any error due to the `set -euo pipefail` directive.

set -euo pipefail

ROOT="$(dirname "$(dirname "$(realpath "$0")")")"

# Default values
PRV_KEY="0x024cf65eb3bc550a1a6675aa21d146d7476fc5b62715d24fb2e0027647a213af"
RPC_URL=http://localhost:8545
CHAIN_ID=1337

# Help function
display_help() {
    echo "This script accepts the following command line arguments:"
    echo "--rpc: the network RPC"
    echo "--chain: the network chain id"
    echo "--private-key: The deployer private key"
    echo ""
    
    echo "For example:"
    echo "bash bin/deploy.sh --rpc $RPC_URL --chain $CHAIN_ID --private-key $PRV_KEY"
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --rpc)
            RPC_URL="$2"
            shift 2
            ;;
        --chain)
            CHAIN_ID="$2"
            shift 2
            ;;
        --private-key)
            PRV_KEY="$2"
            shift 2
            ;;
        --help)
            display_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1. Use --help for more info."
            display_help
            exit 1
            ;;
    esac
done

# get public key from private key
echo "Deployer private key: $PRV_KEY"

# Assumes ``$ forge build`` has already been run
# Deploy the contract using Forge
forge script "$ROOT/script/unsafe.s.sol" --rpc-url $RPC_URL --private-key $PRV_KEY --broadcast
--- ./bin/develop.sh ---
#!/bin/bash

# This script builds Docker images for the core-v2 project using various Dockerfiles.
# It ensures that the builds terminate on any error due to the `set -euo pipefail` directive.
#
# The built images are tagged as:
# - core-v2:base
# - core-v2:latest
# - core-v2:testnet
#
# Usage:
# Simply run the script from the command line:
#   bash develop.sh


set -euo pipefail

ROOT="$(dirname "$(dirname "$(realpath "$0")")")"

docker build -t core-v2:base -f "$ROOT/dockerfiles/core-v2.base.Dockerfile" .
docker build -t core-v2:latest -f "$ROOT/dockerfiles/core-v2.Dockerfile" .
docker build -t core-v2:testnet -f "$ROOT/dockerfiles/testnet.Dockerfile" .
--- ./bin/testnet.sh ---
#!/bin/bash

# This script builds Docker images for the core-v2 project and starts a local testnet.
# It ensures a clean environment by removing any existing testnet containers before starting a new one.

set -euo pipefail

ROOT="$(dirname "$(dirname "$(realpath "$0")")")"

docker build -t core-v2:latest -f "$ROOT/dockerfiles/core-v2.Dockerfile" .
docker build -t core-v2:testnet -f "$ROOT/dockerfiles/testnet.Dockerfile" .

# Remove Docker container if it exists
container_id=$(docker ps -a -q -f name=testnet)
if [ -n "$container_id" ]; then
    docker rm -f $container_id > /dev/null
fi

# Run the rest of the commands inside Docker container
docker run --name testnet -p 8545:8545 core-v2:testnet
--- ./bin/tests.sh ---
#!/bin/bash

# This script builds the core-v2 Docker image and runs Solidity tests within a Docker container.
# It ensures a clean environment by removing any existing test containers before starting a new one.

set -euo pipefail

ROOT="$(dirname "$(dirname "$(realpath "$0")")")"

docker build -t core-v2:latest -f "$ROOT/dockerfiles/core-v2.Dockerfile" .

# Remove Docker container if it exists
container_id=$(docker ps -a -q -f name=solidity-tests)
if [ -n "$container_id" ]; then
    docker rm -f $container_id > /dev/null
fi

docker run --name solidity-tests core-v2:latest /bin/bash -c "forge test"
--- ./bin/testnet-config.sh ---
#!/bin/bash

# This script configures and starts a local Anvil testnet node with a specified genesis file and funded account.
# It ensures the testnet is properly initialized and ready to accept connections before completing.

# Prerequisites:
# - jq: JSON parsing utility. Ensure it is installed and available in the system's PATH.
# - anvil: The Anvil testnet node software. Ensure it is installed and available in the system's PATH.

set -euo pipefail

ROOT="$(dirname "$(dirname "$(realpath "$0")")")"

# Ensure jq is installed for JSON parsing
if ! command -v jq &> /dev/null
then
    echo "jq could not be found. Please install jq to continue."
    exit 1
fi

# Default values
ANVIL_HOST=127.0.0.1
ANVIL_PORT=8545
ANVIL_CHAIN=1337
ANVIL_GENESIS_FILE="$ROOT/genesis.json"
ANVIL_FUNDED_ACCOUNT="0x7C010FD1B3e279ac063d862199484254f27C2C44"

# Help function
display_help() {
    echo "Usage: bash bin/testnet-config.sh [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --host          Testnet host (default: 127.0.0.1)"
    echo "  --port          Testnet port (default: 8545)"
    echo "  --chain         Testnet chain ID (default: 1337)"
    echo "  --genesis       Path to the genesis file (default: $ANVIL_GENESIS_FILE)"
    echo "  --fund-account  Account to be funded in the genesis file (default: $ANVIL_FUNDED_ACCOUNT)"
    echo "  --help          Display this help message"
    echo ""
    echo "This script configures and starts a local Anvil testnet node with the specified parameters."
    echo "It checks if 'jq' is installed, parses command-line arguments, updates the genesis file,"
    echo "and starts the Anvil node. The script waits until the Anvil node is ready to accept connections."
    echo ""
    echo "Example:"
    echo "  bash bin/testnet-config.sh --genesis /path/to/genesis.json --host 127.0.0.1 --port 8545 --chain 1337 --fund-account $ANVIL_FUNDED_ACCOUNT"
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --host)
            ANVIL_HOST="$2"
            shift 2
            ;;
        --port)
            ANVIL_PORT="$2"
            shift 2
            ;;
        --chain)
            ANVIL_CHAIN="$2"
            shift 2
            ;;
        --genesis)
            ANVIL_GENESIS_FILE="$2"
            shift 2
            ;;
        --fund-account)
            ANVIL_FUNDED_ACCOUNT="$2"
            shift 2
            ;;
        --help)
            display_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1. Use --help for more info."
            display_help
            exit 1
            ;;
    esac
done

# Ensure the genesis file contains the correct alloc for the deployer public key
GENESIS_CONTENT=$(jq ".alloc[\"${ANVIL_FUNDED_ACCOUNT}\"] = {\"balance\": \"0xad78ebc5ac6200000\"}" "$ANVIL_GENESIS_FILE")
echo "$GENESIS_CONTENT" > "$ANVIL_GENESIS_FILE"

echo "Genesis file: $ANVIL_GENESIS_FILE"
echo "$GENESIS_CONTENT"

# Start Anvil in the background
echo "- host: $ANVIL_HOST"
echo "- port: $ANVIL_PORT"
echo "- chain: $ANVIL_CHAIN"
anvil --host $ANVIL_HOST --port $ANVIL_PORT --init $ANVIL_GENESIS_FILE --chain-id $ANVIL_CHAIN &

# Wait for avil node to be up and running on port 8545
spinner=( '⠏' '⠛' '⠹' '⢸' '⣰' '⣤' '⣆' '⡇' )

# Wait for anvil node to be up and running on port 8545
while ! (echo > /dev/tcp/localhost/8545) >/dev/null 2>&1; do
    for i in "${spinner[@]}"
    do
        echo -ne "\r$i waiting for anvil to start ..."
        sleep 0.2
    done
done

echo -e "\r... Ready!                      "
--- ./utils/generateTestVectorRSA.py ---
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from eth_abi.packed import encode_packed
from eth_utils import to_bytes
from binascii import hexlify

def pack_message(trading_address, policy_id, creat_before, valid_until, cost, backdoor):
    # Convert the address to bytes
    trading_address_bytes = to_bytes(hexstr=trading_address)
    
    # Encode the values according to the specified types
    message = encode_packed(
        ['address', 'uint24', 'uint32', 'uint32', 'uint168', 'bytes'],
        [trading_address_bytes, policy_id, creat_before, valid_until, cost, backdoor]
    )
    print(hexlify(message))
    return message

# Function to generate RSA key with public exponent 3
def generate_rsa_key_with_exponent_3():
    key = RSA.generate(1024, e=3)
    return key.export_key(), key.publickey().export_key()

def encode_data(trading_address, policy_id, creat_before, valid_until, cost, backdoor):
    return pack_message(trading_address, policy_id, creat_before, valid_until, cost, backdoor)

def sign_message(message, private_key):
    # Hash the message using SHA256
    hash_obj = SHA256.new(message)
    # Sign the message using RSA private key
    rsa_key = RSA.import_key(private_key)
    # verify this is not being hashed internally
    signature = pkcs1_15.new(rsa_key).sign(hash_obj)
    return signature

# Example usage
trading_address = "0x0123456789abcDEF0123456789abCDef01234567"
policy_id = 123456
creat_before = 1625247600
valid_until = 1627849600
cost = 1000000000000000000  # Example cost in wei
backdoor = b"example_backdoor_data"

# Generate a 1024-bit RSA key with public exponent 3 (for demonstration purposes)
private_key, public_key = generate_rsa_key_with_exponent_3()

# Encode the data
encoded_message = encode_data(trading_address, policy_id, creat_before, valid_until, cost, backdoor)

# Sign the encoded message
signature = sign_message(encoded_message, private_key)

rsa_key = RSA.import_key(public_key)

# Print all properly encoded data
print(f"Trading Address: {trading_address}")
print(f"Policy ID: {policy_id}")
print(f"Create Before: {creat_before}")
print(f"Valid Until: {valid_until}")
print(f"Cost: {cost}")
print(f"Backdoor: {backdoor.hex()}")
print(f"Encoded Message: {encoded_message.hex()}")
print(f"Key: {hex(rsa_key.public_key().n)[2:]}")
print(f"Signature: {signature.hex()}")

# For verification (optional)
def verify_signature(public_key, message, signature):
    rsa_key = RSA.import_key(public_key)
    hash_obj = SHA256.new(message)
    try:
        pkcs1_15.new(rsa_key).verify(hash_obj, signature)
        print("The signature is valid.")
    except (ValueError, TypeError):
        print("The signature is not valid.")

# Verify the signature (optional)
verify_signature(public_key, encoded_message, signature)

--- ./test/RsaVerifyOptimizedTest.t.sol ---
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/lib/RsaVerifyOptimized.sol";

contract RsaVerifyOptimizedTestRig is RsaVerifyOptimized {
    function verify(
        address tradingAddress,
        uint256 policyId,
        uint256 createBefore,
        uint256 validUntil,
        uint256 cost,
        bytes calldata key,
        bytes calldata signature,
        bytes calldata backdoor
    ) public view returns (bool) {
        return verifyAuthMessage(tradingAddress, policyId, createBefore, validUntil, cost, key, signature, backdoor);
    }
}

contract KeyringCoreV2UnsafeTest is Test {
    RsaVerifyOptimizedTestRig internal keyring;

    function setUp() public {
        keyring = new RsaVerifyOptimizedTestRig();
    }

    function testVerify() public {
        // Trading Address: 0x0123456789abcDEF0123456789abCDef01234567
        // Policy ID: 123456
        // Create Before: 1625247600
        // Valid Until: 1627849600
        // Cost: 1000000000000000000
        // Backdoor: 6578616d706c655f6261636b646f6f725f64617461
        // Encoded Message: 0123456789abcdef0123456789abcdef0123456701e24060df4f70610703800000000000000000000000000de0b6b3a76400006578616d706c655f6261636b646f6f725f64617461
        // Key:       efe9bea006e5d2c7404daa0cce525fbbf0a782f43693df882faec03d7f1f6183a57cedf766107a3316ffdd7ae39d999e07a0c91a495b5852fac60a5ea20427a240f40183c1895a1520e8cab08da0074252c9ad27fc3eef5ddff300a584b9286d9556843f1e6ec3b3eb625af2e4fe5022c151888e6d40400e8796dc9728c7a6c5
        // Signature: a38c7dce2f90e42c6ec96972721e4dbc7bd23f6c9abd24004d2d56ab8f96599113a44f387555e277f8a2d95a70f1e308298f48462544d9ddbaff4c613eece2690bb7c7236f969f1f31d199ba9ee9299dc2dc7586dee78272dd474dbba7a5d8c37f6f306cdebf387a5cc0ceefef5de07604f8af2a611ec3667b1d159cc5c07675
        address tradingAddress = 0x0123456789abcDEF0123456789abCDef01234567;
        uint256 policyId = 123456;
        uint256 createBefore = 1625247600;
        uint256 validUntil = 1627849600;
        uint256 cost = 1000000000000000000;
        bytes memory backdoor = hex"6578616d706c655f6261636b646f6f725f64617461";
        bytes memory key = hex"efe9bea006e5d2c7404daa0cce525fbbf0a782f43693df882faec03d7f1f6183a57cedf766107a3316ffdd7ae39d999e07a0c91a495b5852fac60a5ea20427a240f40183c1895a1520e8cab08da0074252c9ad27fc3eef5ddff300a584b9286d9556843f1e6ec3b3eb625af2e4fe5022c151888e6d40400e8796dc9728c7a6c5";
        bytes memory signature = hex"a38c7dce2f90e42c6ec96972721e4dbc7bd23f6c9abd24004d2d56ab8f96599113a44f387555e277f8a2d95a70f1e308298f48462544d9ddbaff4c613eece2690bb7c7236f969f1f31d199ba9ee9299dc2dc7586dee78272dd474dbba7a5d8c37f6f306cdebf387a5cc0ceefef5de07604f8af2a611ec3667b1d159cc5c07675";
        uint256 gasBefore = gasleft();
        bool result = keyring.verify(tradingAddress, policyId, createBefore, validUntil, cost, key, signature, backdoor);
        uint256 gasAfter = gasleft();
        emit log_named_uint("Gas Used:", gasBefore - gasAfter);
        assertTrue(result);
    }
}

--- ./test/KeyringCoreV2BaseTest.t.sol ---
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/unsafe/KeyringCoreV2Unsafe.sol";


contract KeyringCoreV2UnsafeTest is Test {
    KeyringCoreV2Unsafe internal keyring;
    address internal admin;
    address internal nonAdmin;
    bytes32 internal testKeyHash;
    bytes internal testKey;

    function setUp() public {
        admin = address(this);
        nonAdmin = address(0x123);
        keyring = new KeyringCoreV2Unsafe();
        testKey = hex"abcd";
        testKeyHash = keyring.getKeyHash(testKey);
        vm.warp(1704067200); // 01-01-2024 00:00:00
    }

    // Constructor and Admin Initialization Test
    function testConstructorInitialAdmin() public {
        assertEq(keyring.admin(), admin);
    }

    // Admin Functionality Tests
    function testSetAdminByAdmin() public {
        keyring.setAdmin(nonAdmin);
        assertEq(keyring.admin(), nonAdmin);
    }

    function testSetAdminByNonAdmin() public {
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.setAdmin(nonAdmin);
    }

    // Key Registration Tests
    function testRegisterKeyByAdmin() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        assertTrue(keyring.keyExists(testKeyHash));
    }

    function testRegisterKeyByNonAdmin() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.registerKey(validFrom, validTo, testKey);
    }

    function testRegisterKeyInvalidTime() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom - 1 days;
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidKeyRegistration.selector, "IVP"));
        keyring.registerKey(validFrom, validTo, testKey);
    }

    function testRegisterKeyAlreadyRegistered() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidKeyRegistration.selector, "KAR"));
        keyring.registerKey(validFrom, validTo, testKey);
    }

    // Key Revocation Tests
    function testRevokeKeyByAdmin() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        keyring.revokeKey(testKeyHash);
        assertFalse(keyring.keyExists(testKeyHash));
    }

    function testRevokeKeyByNonAdmin() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.revokeKey(testKeyHash);
    }

    function testRevokeNonExistentKey() public {
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrKeyNotFound.selector, testKeyHash));
        keyring.revokeKey(testKeyHash);
    }

    // Entity Blacklisting Tests
    function testBlacklistEntityByAdmin() public {
        keyring.blacklistEntity(1, nonAdmin);
        assertTrue(keyring.entityBlacklisted(1, nonAdmin));
    }

    function testBlacklistEntityByNonAdmin() public {
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.blacklistEntity(1, nonAdmin);
    }

    function testUnblacklistEntityByAdmin() public {
        keyring.blacklistEntity(1, nonAdmin);
        keyring.unblacklistEntity(1, nonAdmin);
        assertFalse(keyring.entityBlacklisted(1, nonAdmin));
    }

    function testUnblacklistEntityByNonAdmin() public {
        keyring.blacklistEntity(1, nonAdmin);
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.unblacklistEntity(1, nonAdmin);
    }

    function testCredentialCreationExpired() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 2 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 2 days;
        uint256 validUntil = block.timestamp + 1 days;
        vm.warp(block.timestamp + 1 days + 1 minutes);

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "EXP"));
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    // Credential Creation Tests
    function testCreateCredentialOk() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        uint256 gasBefore = gasleft();
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        uint256 gasAfter = gasleft();
        assertTrue(keyring.checkCredential(1, nonAdmin));
        emit log_named_uint("Gas for COLD COST credential without RSA validation:", gasBefore - gasAfter);
        
        gasBefore = gasleft();
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        gasAfter = gasleft();
        emit log_named_uint("Gas for HOT COST credential without RSA validation:", gasBefore - gasAfter);
        
        gasBefore = gasleft();
        keyring.createCredential(nonAdmin, 1, createBefore, validUntil, 0, testKey, "", "");
        gasAfter = gasleft();
        emit log_named_uint("Gas for HOT NO-COST credential without RSA validation:", gasBefore - gasAfter);
        
        gasBefore = gasleft();
        keyring.checkCredential(1, nonAdmin);
        gasAfter = gasleft();
        emit log_named_uint("Gas for checkCredential:", gasBefore - gasAfter);
    }

    function testCreateCredentialInsufficientPayment() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "VAL"));
        keyring.createCredential{value: 0.5 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    function testCreateCredentialInvalidKey() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        vm.warp(block.timestamp + 2 days);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "BDK"));
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    function testCreateCredentialOutsideCreateBefore() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp - 1 days;
        uint256 validUntil = block.timestamp + 1 days;

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "EPO"));
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    function testCreateCredentialBlacklistedEntity() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        keyring.blacklistEntity(1, nonAdmin);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "BLK"));
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    function testCreateCredentialExpirationInPast() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 2 days;
        uint256 validUntil = block.timestamp + 1 days;

        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrInvalidCredential.selector, 1, nonAdmin, "BDK"));
        vm.warp(block.timestamp + 2 days);
        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
    }

    // Fee Collection Tests
    function testCollectFeesByAdmin() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        uint256 balanceBefore = address(this).balance;
        uint256 keyringBalanceBefore = address(keyring).balance;
        keyring.collectFees(admin);
        uint256 balanceAfter = address(this).balance;
        uint256 keyringBalanceAfter = address(keyring).balance;
        assertEq(balanceAfter, balanceBefore + 1 ether);
        assertEq(keyringBalanceAfter, keyringBalanceBefore - 1 ether);
    }

    function testCollectFeesByNonAdmin() public {
        vm.prank(nonAdmin);
        vm.expectRevert(abi.encodeWithSelector(KeyringCoreV2Base.ErrCallerNotAdmin.selector, 0x0000000000000000000000000000000000000123));
        keyring.collectFees(address(this));
    }

    // View Function Tests
    function testAdmin() public {
        assertEq(keyring.admin(), admin);
    }

    function testGetKeyHash() public {
        assertEq(keyring.getKeyHash(testKey), testKeyHash);
    }

    function testKeyExists() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        assertTrue(keyring.keyExists(testKeyHash));
        keyring.revokeKey(testKeyHash);
        assertFalse(keyring.keyExists(testKeyHash));
    }

    function testKeyValidFrom() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        assertEq(keyring.keyValidFrom(testKeyHash), validFrom);
    }

    function testKeyValidTo() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        assertEq(keyring.keyValidTo(testKeyHash), validTo);
    }

    function testKeyDetails() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        KeyringCoreV2Base.KeyEntry memory kd = keyring.keyDetails(testKeyHash);
        assertEq(kd.validFrom, validFrom);
        assertEq(kd.validTo, validTo);
        assertTrue(kd.isValid);
    }

    function testEntityBlacklisted() public {
        keyring.blacklistEntity(1, nonAdmin);
        assertTrue(keyring.entityBlacklisted(1, nonAdmin));
        keyring.unblacklistEntity(1, nonAdmin);
        assertFalse(keyring.entityBlacklisted(1, nonAdmin));
    }

    function testEntityExp() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        assertEq(keyring.entityExp(1, nonAdmin), validUntil);
    }

    function testEntityData() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        KeyringCoreV2Base.EntityData memory ed = keyring.entityData(1, nonAdmin);
        assertTrue(ed.exp == keyring.entityExp(1, nonAdmin));
        assertTrue(ed.blacklisted == false);
    }

    function testCheckCredential() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        assertTrue(keyring.checkCredential(1, nonAdmin));
    }

    function testCheckCredentialExpired() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        uint256 ts = block.timestamp + 2 days;
        vm.warp(ts + 1);
        assertFalse(keyring.checkCredential(1, nonAdmin)); // Should fail due to expiration
    }

    function testCheckCredentialBlacklisted() public {
        uint256 validFrom = block.timestamp;
        uint256 validTo = validFrom + 1 days;
        keyring.registerKey(validFrom, validTo, testKey);
        uint256 createBefore = block.timestamp + 5 minutes;
        uint256 validUntil = block.timestamp + 1 days;

        keyring.createCredential{value: 1 ether}(nonAdmin, 1, createBefore, validUntil, 1 ether, testKey, "", "");
        keyring.blacklistEntity(1, nonAdmin);
        assertFalse(keyring.checkCredential(1, nonAdmin)); // Should fail due to blacklisting
    }

    fallback() external payable {}
}

--- ./script/unsafe.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "../src/unsafe/KeyringCoreV2Unsafe.sol";

contract DeployScript is Script {
    function run() external {
        vm.startBroadcast();

        // Deploy the contract
        KeyringCoreV2Unsafe c = new KeyringCoreV2Unsafe();

        console.log("Contract deployed at:", address(c));

        vm.stopBroadcast();
    }
}
--- ./src/KeyringCoreV2.sol ---
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "./lib/RsaVerifyOptimized.sol";
import "./base/KeyringCoreV2Base.sol";

// NOTE: MAKE EXP PER POLICY VARIANT UPPER BOUND OF MORE THAN 1/2 EPOCH HANDLE IN FE
// NOTE: HANDLED BY BACKEND. WHAT ARE THE ELEMENTS THAT ARE PART OF A POLICY - NO NEED TO TRACK IN CHAIN
// NOTE: RSA KEYS PER POLICY ENFORCED BY BACKEND
// NOTE: LIST OF WALLET CHECKERS PER POLICY NOT ABLE TO PERFORM AS BLACKLISTING IS GLOBAL
// NOTE: PER POLICY BACKDOOR MUST BE HANDLED BY BACKEND
// NOTE: ECDSA FOR NON ZK CREDENTIAL

// QUESTION: SHOULD WE INVALIDATE CREDENTIALS FOR A REVOKED KEY
// QUESTION: SHOULD THERE BE A PER POLICY BLACKLIST
// QUESTION: SHOULD WE DO A PER POLICY CREATE2 SYSTEM OR THIS GLOBAL SYSTEM

contract KeyringCoreV2 is KeyringCoreV2Base, RsaVerifyOptimized {
    constructor() KeyringCoreV2Base() {}

    function createCredential(
        address tradingAddress,
        uint256 policyId,
        uint256 epoch,
        uint256 epochExp,
        uint256 cost,
        bytes calldata key,
        bytes calldata signature,
        bytes calldata backdoor
    ) public payable override {
        if (!verifyAuthMessage(tradingAddress, uint24(policyId), uint32(epoch), uint32(epochExp), uint168(cost), key, signature, backdoor)) {
            revert ErrInvalidCredential(policyId, tradingAddress, "SIG");
        }
        super._createCredential(tradingAddress, policyId, epoch, epochExp, cost, key, backdoor);
    }
}
--- ./src/unsafe/KeyringCoreV2Unsafe.sol ---
// SPDX-License-Identifier: UNLICENSED

/*
THIS CONTRACT IS FOR TESTING PURPOSES ONLY. DO NOT USE IN PRODUCTION.
*/
pragma solidity ^0.8.20;

import "../base/KeyringCoreV2Base.sol";

contract KeyringCoreV2Unsafe is KeyringCoreV2Base {
    constructor() KeyringCoreV2Base() {}
}
--- ./src/base/KeyringCoreV2Base.sol ---
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

/**
 * @title KeyringCoreV2 Contract
 * @dev This contract manages policy states, credentials, and whitelisting/blacklisting of entities.
 */
abstract contract KeyringCoreV2Base {

    /**
     * @notice Represents data associated with an entity.
     * @dev Contains whitelisting status and expiration information.
     * @param PADDING Padding bytes.
     * @param blacklisted Indicates if the entity is blacklisted.
     * @param exp The expiration for the entity's credential.
     */
    struct EntityData {
        bool blacklisted;
        uint64 exp;
    }

    /**
     * @notice Represents a key entry.
     * @dev Contains validity status and the validity period of the key.
     * @param PADDING Padding bytes.
     * @param isValid Indicates if the key is valid.
     * @param validFrom The start time of the key's validity.
     * @param validTo The end time of the key's validity.
     */
    struct KeyEntry {
        bool isValid;
        uint64 validFrom;
        uint64 validTo;
    }

    /// @notice Error for unauthorized admin caller.
    /// @param caller The address of the unauthorized caller.
    error ErrCallerNotAdmin(address caller);

    /// @notice Error for invalid key registration.
    /// @param reason The reason for the invalid key registration.
    error ErrInvalidKeyRegistration(string reason);

    /// @notice Error for expired credential.
    /// @param policyId The ID of the policy.
    /// @param entity The address of the entity.
    /// @param reason The reason for the invalid credential.
    error ErrInvalidCredential(uint256 policyId, address entity, string reason);

    /// @notice Error for key not found.
    /// @param keyHash The hash of the key that was not found.
    error ErrKeyNotFound(bytes32 keyHash);

    /// @notice Event emitted when a key is registered.
    /// @param keyHash The hash of the key.
    /// @param validFrom The start time of the key's validity.
    /// @param validTo The end time of the key's validity.
    /// @param publicKey The public key.
    event KeyRegistered(bytes32 indexed keyHash, uint256 indexed validFrom, uint256 indexed validTo, bytes publicKey);

    /// @notice Event emitted when a key is revoked.
    /// @param keyHash The hash of the key.
    event KeyRevoked(bytes32 indexed keyHash);

    /// @notice Event emitted when a credential is created.
    /// @param policyId The ID of the policy.
    /// @param entity The address of the entity.
    /// @param exp The expiration for the credential.
    /// @param backdoor The backdoor data.
    event CredentialCreated(uint256 indexed policyId, address indexed entity, uint256 indexed exp, bytes backdoor);

    /// @notice Event emitted when a credential is revoked.
    /// @param policyId The ID of the policy.
    /// @param entity The address of the entity.
    event CredentialRevoked(uint256 indexed policyId, address indexed entity);

    /// @notice Event emitted when an entity is blacklisted.
    /// @param policyId The ID of the policy.
    /// @param entity The address of the entity.
    event EntityBlacklisted(uint256 indexed policyId, address indexed entity);

    /// @notice Event emitted when an entity is unblacklisted.
    /// @param policyId The ID of the policy.
    /// @param entity The address of the entity.
    event EntityUnblacklisted(uint256 indexed policyId, address indexed entity);

    /// @dev Address of the admin.
    address private _admin;

    /// @dev Mapping from key hash to key entry.
    mapping(bytes32 => KeyEntry) private _keys;

    /// @dev Mapping from policy ID and address to entity data.
    mapping(uint256 => mapping(address => EntityData)) private _entityData;

    /**
     * @dev Initializes the contract setting the deployer as the initial admin.
     */
    constructor() {
        _admin = msg.sender;
    }

    // VIEW FUNCTIONS

    /**
     * @notice Returns the address of the admin.
     * @return The address of the admin.
     */
    function admin() public view returns (address) {
        return _admin;
    }

    /**
     * @notice Returns the hash of a key.
     * @param key The key.
     * @return The hash of the key.
     */
    function getKeyHash(bytes memory key) public pure returns (bytes32) {
        return keccak256(key);
    }

    /**
     * @notice Checks if a key exists.
     * @param keyHash The hash of the key.
     * @return True if the key exists, false otherwise.
     */
    function keyExists(bytes32 keyHash) public view returns (bool) {
        return _keys[keyHash].isValid;
    }

    /**
     * @notice Returns the validity start time of a key.
     * @param keyHash The hash of the key.
     * @return The start time of the key's validity.
     */
    function keyValidFrom(bytes32 keyHash) public view returns (uint256) {
        return _keys[keyHash].validFrom;
    }

    /**
     * @notice Returns the validity end time of a key.
     * @param keyHash The hash of the key.
     * @return The end time of the key's validity.
     */
    function keyValidTo(bytes32 keyHash) public view returns (uint256) {
        return _keys[keyHash].validTo;
    }

    /**
     * @notice Returns the details of a key.
     * @param keyHash The hash of the key.
     * @return The KeyEntry struct containing key details.
     */
    function keyDetails(bytes32 keyHash) public view returns (KeyEntry memory) {
        return _keys[keyHash];
    }

    /**
     * @notice Checks if an entity is blacklisted for a specific policy.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity.
     * @return True if the entity is blacklisted, false otherwise.
     */
    function entityBlacklisted(uint256 policyId, address entity_) public view returns (bool) {
        return _entityData[policyId][entity_].blacklisted;
    }

    /**
     * @notice Returns the expiration of an entity for a specific policy.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity.
     * @return The expiration of the entity credential.
     */
    function entityExp(uint256 policyId, address entity_) public view returns (uint256) {
        return _entityData[policyId][entity_].exp;
    }

    /**
     * @notice Returns the data associated with a specific entity.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity.
     * @return The EntityData struct containing blacklisting and expiration information.
     */
    function entityData(uint256 policyId, address entity_) public view returns (EntityData memory) {
        return _entityData[policyId][entity_];
    }

    /**
     * @notice Checks if an entity has a valid credential.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity to check.
     * @return True if the entity has a valid credential, false otherwise.
     */
    function checkCredential(uint256 policyId, address entity_) public view returns (bool) {
        EntityData memory ed = _entityData[policyId][entity_];
        if (!ed.blacklisted && ed.exp > block.timestamp) {
            return true;
        }
        return false;
    }

    // CREDENTIAL CREATION

    /**
     * @notice Creates a credential for an entity.
     * @param tradingAddress The trading address.
     * @param policyId The policy ID.
     * @param epoch The epoch time.
     * @param epochExp The epoch expiration time.
     * @param cost The cost of the credential.
     * @param key The RSA key.
     * @param signature The signature.
     * @param backdoor The backdoor data.
     */
    function createCredential(
        address tradingAddress,
        uint256 policyId,
        uint256 epoch,
        uint256 epochExp,
        uint256 cost,
        bytes calldata key,
        bytes calldata signature,
        bytes calldata backdoor
    ) public virtual payable {
        _createCredential(tradingAddress, policyId, epoch, epochExp, cost, key, backdoor);
    }

    // ADMIN CAPABILITIES

    /**
     * @notice Sets a new admin.
     * @param newAdmin The address of the new admin.
     * @dev Only callable by the current admin.
     */
    function setAdmin(address newAdmin) external {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        _admin = newAdmin;
    }

    /**
     * @notice Registers a new RSA key.
     * @param validFrom The start time of the key's validity.
     * @param validTo The end time of the key's validity.
     * @param key The RSA key.
     * @dev Only callable by the admin.
     */
    function registerKey(uint256 validFrom, uint256 validTo, bytes memory key) external {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        if (validTo <= validFrom) {
            revert ErrInvalidKeyRegistration("IVP");
        }
        bytes32 keyHash = getKeyHash(key);
        if (_keys[keyHash].isValid) {
            revert ErrInvalidKeyRegistration("KAR");
        }
        _keys[keyHash] = KeyEntry(true, uint64(validFrom), uint64(validTo));
        emit KeyRegistered(keyHash, validFrom, validTo, key);
    }

    /**
     * @notice Revokes an RSA key.
     * @param keyHash The hash of the key to revoke.
     * @dev Only callable by the admin.
     */
    function revokeKey(bytes32 keyHash) external {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        if (!_keys[keyHash].isValid) {
            revert ErrKeyNotFound(keyHash);
        }

        _keys[keyHash].isValid = false;
        emit KeyRevoked(keyHash);
    }

    /**
     * @notice Blacklists an entity.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity to blacklist.
     * @dev Only callable by the admin.
     */
    function blacklistEntity(uint256 policyId, address entity_) public {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        EntityData memory ed = EntityData(true, 0);
        _entityData[policyId][entity_] = ed;
        emit EntityBlacklisted(policyId, entity_);
    }

    /**
     * @notice Removes an entity from the blacklist.
     * @param policyId The ID of the policy.
     * @param entity_ The address of the entity to unblacklist.
     * @dev Only callable by the admin.
     */
    function unblacklistEntity(uint256 policyId, address entity_) public {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        EntityData memory ed = EntityData(false, 0);
        _entityData[policyId][entity_] = ed;
        emit EntityUnblacklisted(policyId, entity_);
    }

    /**
    * @notice Collects fees and transfers them to the specified address.
    * @param to The address to transfer the collected fees to.
    * @dev Only callable by the admin.
    * @custom:requires msg.sender must be the admin.
    * @custom:emits This function does not emit any events.
    * @custom:throws ErrCallerNotAdmin if the caller is not the admin.
    */
    function collectFees(address to) public {
        if (msg.sender != _admin) {
            revert ErrCallerNotAdmin(msg.sender);
        }
        payable(to).transfer(address(this).balance);
    }



    // INTERNAL FUNCTIONS

    /**
     * @notice Internal function that creates a credential for an entity.
     * @param tradingAddress The trading address.
     * @param policyId The policy ID.
     * @param creatBefore The time after which the credential is no longer valid for creation.
     * @param validUntil The expiration time of the credential.
     * @param cost The cost of the credential.
     * @param key The RSA key.
     * @param backdoor The backdoor data.
     */
    function _createCredential(
        address tradingAddress,
        uint256 policyId,
        uint256 creatBefore,
        uint256 validUntil,
        uint256 cost,
        bytes calldata key,
        bytes calldata backdoor) internal { 
        // Verify the cost of the credential creation matches the value sent.
        if (msg.value != cost) {
            revert ErrInvalidCredential(policyId, tradingAddress, "VAL");
        }
        // Verify the key is valid.
        uint256 currentTime = block.timestamp;
        {
            bytes32 keyHash = getKeyHash(key);
            KeyEntry memory entry = _keys[keyHash];
            bool isValid = (entry.isValid && currentTime >= entry.validFrom && currentTime <= entry.validTo);
            // Verify the key is valid.
            if (!isValid) {
                revert ErrInvalidCredential(policyId, tradingAddress, "BDK");
            }
        }
        {
            if (block.timestamp > creatBefore) {
                revert ErrInvalidCredential(policyId, tradingAddress, "EPO");
            }
        }
        // Load the entity data.
        EntityData memory ed = _entityData[policyId][tradingAddress];
        // Check if the entity is blacklisted.
        if (ed.blacklisted) {
            revert ErrInvalidCredential(policyId, tradingAddress, "BLK");
        }
        // Calculate the expiration for the credential.
        if (validUntil < currentTime) {
            revert ErrInvalidCredential(policyId, tradingAddress, "EXP");
        }
        // Set the expiration for the entity.
        ed.exp = uint64(validUntil);
        _entityData[policyId][tradingAddress] = ed;
        // Update the entity data.
        // Emit the credential created event.
        emit CredentialCreated(policyId, tradingAddress, validUntil, backdoor);
    }

}
